# Tool Chain Used

## Linux command line tips

```bash
# To get the timezone at the command prompt
# in this case South African Standard Time
date +%Z
>SAST

# To display timezone information at command prompt
timedatectl
>                      Local time: Thu 2019-02-28 17:35:12 SAST
>                  Universal time: Thu 2019-02-28 15:35:12 UTC
>                        RTC time: Thu 2019-02-28 15:35:12
>                       Time zone: Africa/Johannesburg (SAST, +0200)
>       System clock synchronized: yes
>systemd-timesyncd.service active: yes
>                 RTC in local TZ: no

#To display a list of valid timezones
timedatectl list-timezones | grep "Johannesburg"
>Africa/Johannesburg
>Africa/Juba
>Africa/Kampala
>Africa/Khartoum
>Africa/Kigali
>Africa/Kinshasa
>Africa/Lagos
>Africa/Libreville
>Africa/Lome

# .. and with systemd systems we can see some info about NTP
timedatectl status
>                      Local time: Thu 2019-02-28 17:42:54 SAST
>                  Universal time: Thu 2019-02-28 15:42:54 UTC
>                        RTC time: Thu 2019-02-28 15:42:54
>                       Time zone: Africa/Johannesburg (SAST, +0200)
>       System clock synchronized: yes
>systemd-timesyncd.service active: yes
>                 RTC in local TZ: no

...


```


## Useful PostgreSQL tips

```SQL
--- Some cool things to do in psql include:
\pset pager off
\! clear
\! date +%Z
\! cal 9 1966
SHOW timezone;
SELECT timestamp with time zone 'tomorrow';
SELECT * from pg_timezone_names ;
SET timezone='Africa/Johannesburg';
SELECT timestamp with time zone 'tomorrow';
SELECT timestamp 'epoch';
SELECT timestamp 'infinity';
SELECT time 'allballs';
--- Some tips for working with hashes
CREATE EXTENSION pgcrypto;
SELECT md5(random()::text || clock_timestamp()::text)::uuid;
SELECT gen_salt('md5');
SELECT gen_random_uuid();
```

## Docker tips
We assume that you have installed docker.io and docker-compose 
To download and run the postgres dockerhub image is as easy as the following:
```
docker pull postgres
docker run -d --name db8 -p 9432:5432 postgres
```

We could choose to tag the pull to the version 10 instance as our current stable version eg postgres:10 
but the logical replication is a new feature in postgres and we will just use the latest version from this point.
Post 9432 would be the local port mapped on our machine i.e. localhost:9432
The tac d detaches the container, the tactac name is used because we want to know what our containers are called without relying on an autogenerated name.

To see running containers ...
```
docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS                    NAMES
45e5508a561e        postgres            "docker-entrypoint.s…"   40 seconds ago       Up 39 seconds       0.0.0.0:7432->5432/tcp   db-canonical
48b863927ebc        postgres            "docker-entrypoint.s…"   About a minute ago   Up About a minute   0.0.0.0:8432->5432/tcp   db-microservice2
c104b9aa4caf        postgres            "docker-entrypoint.s…"   About a minute ago   Up About a minute   0.0.0.0:9432->5432/tcp   db-microservice1
```

When there is a problem on docker startup the following is helpful in a secodnary terminal:
```
docker logs db-canonical --follow
```
and if you need to know anything about the docker networking, this may help:
```
docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' db-microservice1
docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' db-canonical
```

when making changes to the postgres.conf settings with SET wal_level = logical we need to restart the container using a docker container management command, as follows:
```
docker container restart db-canonical
``` 

## Docker Compose
When we want to run several docker containers as part of a solution, demo or proof of concept we can setup several containers all at the same time.

Here is the docker-compose.yml that will build the containers we use in this proof of concept:
```
version: '3'

services:
  db-fica:
    image: postgres
    ports:
      - "9432:5432"
    networks:
      - microservice_net
    container_name: db-fica
    tty: true
    stdin_open: true

  db-jibar:
    image: postgres
    ports:
      - "8432:5432"
    networks:
      - microservice_net
    container_name: db-jibar
    tty: true
    stdin_open: true

  db-canonical:
    image: postgres
    ports:
      - "7432:5432"
    networks:
      - microservice_net
    container_name: db-canonical
    tty: true
    stdin_open: true

networks:
  microservice_net:
      driver: bridge
```
This is a reliable and predictable way of bringing these containers up and down.
```
docker-compose up -d
docker-compose down --remove-orphans
```

-------
# How we got a copy of the default postgres.conf and set ** wal_level = logical **
```
docker run -i  --rm postgres cat /usr/share/postgresql/postgresql.conf.sample > my-postgres.conf
```
then we use this my-postgres.conf when starting our db containers..
```
docker run --rm -d -p 9432:5432 -v /home/andrew/dev/temporal_tables/my-postgres.conf:/etc/postgresql.conf --name db -e POSTGRES_PASSWORD=postgres postgres -c config_file=/etc/postgresql.conf
```
-------
# How we connect and create the database in the container
```
PGPASSWORD=postgres createdb -h localhost -p 9432 -U postgres db-microservice1
```
-------
# How we import the temporal_tables versioning function into the canonical_db -p 7432
```
PGPASSWORD=postgres psql -h localhost -p 7432 -U postgres canonical_db < versioning_function.sql
```


  






